{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#about","title":"About","text":"<p>Voyager is a Roblox API wrapper for Discord webhooks. Voyager makes sending requests to Discord webhooks from Roblox much easier, as you not only write less code but the code you do write is much more readable too, this results in a much better developer experience. Voyager also has very good API coverage over Discord's webhook API, so no matter how niche your use case is, Voyager can most likely help you out!</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Simple: Voyager is curated to be easily utilized by both beginner and advanced scripters.</li> <li>Flexible: Voyager is curated to be modular as to fit as many use cases as possible.</li> <li>Pre-request data validation: Voyager comes with built in validation functions that automatically validate any data you give it before making an HTTP request. This is done to mitigate making pointless requests to the proxy, as making too many bad requests may get you temporarily or indefinitely banned from the proxy.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ol> <li>Get the module script.</li> <li>Make sure HTTP requests in Game Settings &gt; Security is enabled.</li> <li>Drag the module into your project and place it in ServerScriptService or ServerStorage.</li> <li>Now you can use Voyager!</li> </ol>"},{"location":"#tutorial","title":"Tutorial","text":"<p>Learn how to use Voyager here.</p>"},{"location":"With%20vs%20without%20Voyager/","title":"With vs without Voyager","text":""},{"location":"With%20vs%20without%20Voyager/#goal","title":"Goal","text":"<p>Make a script that sends a Discord message with embedded content that displays the player's feedback.</p>"},{"location":"With%20vs%20without%20Voyager/#with-voyager","title":"With Voyager","text":"examples\\playerFeedback.lua"},{"location":"With%20vs%20without%20Voyager/#without-voyager","title":"Without Voyager","text":"<pre><code>-- Make a remote event called \"SendFeedback\" in replicated storage\nlocal sendFeedbackRemote = game:GetService(\"ReplicatedStorage\").SendFeedback\nlocal httpService = game:GetService(\"HttpService\")\nsendFeedbackRemote.OnServerEvent:Connect(function(player : Player, feedback : string)\nlocal requestBody = {\n[\"embeds\"] = {\n{\n[\"description\"] = feedback,\n[\"author\"] = {\n[\"name\"] = \"Feedback from \" .. player.DisplayName,\n[\"url\"] = \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\"\n},\n[\"color\"] = 34815,\n[\"timestamp\"] = os.date(\"!%Y-%m-%dT%H:%M:%S.\" .. math.round(tick() % 1 * 1000) .. \"Z\"),\n[\"fields\"] = {\n{\n[\"name\"] = \"Account Age\",\n[\"value\"] = \"**\" .. player.AccountAge .. \"** Days\",\n[\"inline\"] = true\n},\n{\n[\"name\"] = \"Has Verified Badge?\",\n[\"value\"] = tostring(player.HasVerifiedBadge),\n[\"inline\"] = true\n},\n{\n[\"name\"] = \"From Game\",\n[\"value\"] = \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\",\n[\"inline\"] = true\n}\n}\n}\n}\n}\nlocal responce = httpService:RequestAsync({\nUrl = \"https://webhook.lewisakura.moe/api/webhooks/webhookId/webhookToken/queue\",\nMethod = \"POST\",\nHeaders = {[\"Content-Type\"] = \"application/json\"},\nBody = httpService:JSONEncode(requestBody)\n})\nif not responce.Success then\nwarn(\"Request was not successful! \" .. responce.StatusCode .. \" \" .. responce.StatusMessage)\nend\nend)\n</code></pre>"},{"location":"API%20Reference/Author/","title":"Author","text":""},{"location":"API%20Reference/Author/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/Author/#authorid-string","title":"Author.id : string","text":"<p>The author's discord id.</p> <p></p> <p></p>"},{"location":"API%20Reference/Author/#authorusername-string","title":"Author.username : string","text":"<p>The author's discord username.</p> <p></p> <p></p>"},{"location":"API%20Reference/Author/#authoravatar-string","title":"Author.avatar : string","text":"<p>The author's discord avatar hash.</p> <p></p> <p></p>"},{"location":"API%20Reference/Author/#authordiscriminator-string","title":"Author.discriminator : string","text":"<p>The author's discord discriminator.</p> Deprecation Notice <p>This property has been deprecated. Please edit any code that uses it as it will be removed soon.</p> <p></p> <p></p>"},{"location":"API%20Reference/Author/#authorbot-boolean","title":"Author.bot : boolean","text":"<p>Whether the author is a bot.</p> <p></p> <p></p>"},{"location":"API%20Reference/Author/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/Author/#authornewdata-dictionary-author","title":"Author.new(data : dictionary) : Author","text":"<p>This method returns a new Author object.</p> Warning <p>This method is not meant to be called outside of Voyager's internal code.</p> <p>Parameters</p> <ul> <li>data: An author object.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Author/#authorgetavatarurlsize-number-imageformat-string-string","title":"Author:getAvatarUrl(size : number?, imageFormat : string?) : string","text":"<p>This method will return the author's avatar url.</p> Warning <p>The size parameter can only be a power of two between 16 and 4096.</p> Info <p>If the imageFormat paramiter is left out. It will defualt to .png.</p> Tip <p>Use Enum.AvatarImageFormats to fill in the imageFormat parameter.</p> <p>Parameters</p> <ul> <li>size: The desired size the avatar should be.</li> <li>imageFormat: The format the author's avatar should be returned as.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Author/#authorhasanimatedavatar-boolean","title":"Author:hasAnimatedAvatar() : boolean","text":"<p>This method checks whether the author has an animated avatar.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/","title":"EditedMessage","text":""},{"location":"API%20Reference/EditedMessage/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/EditedMessage/#editedmessageid-string","title":"EditedMessage.id : string","text":"<p>The message's id.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessagemessagetype-number","title":"EditedMessage.messageType : number","text":"<p>The type of message the message is.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessagecontent-string","title":"EditedMessage.content : string","text":"<p>The message's content.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessagechannelid-string","title":"EditedMessage.channelId : string","text":"<p>The id of the channel the message was sent in.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessageauthor-author","title":"EditedMessage.author : Author","text":"<p>The the author of the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessageembeds-number-embed","title":"EditedMessage.embeds : {[number] : Embed}","text":"<p>A table of embeds that are attached to the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessagereactions-number-reaction","title":"EditedMessage.reactions : {[number] : Reaction}","text":"<p>A table of reactions that were added to the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessagementions-number-user","title":"EditedMessage.mentions : {[number] : User}","text":"<p>A table of users mentioned in the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessagementionroles-number-string","title":"EditedMessage.mentionRoles : {[number] : string}","text":"<p>A table of role ids mentioned in the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessagepinned-boolean","title":"EditedMessage.pinned : boolean","text":"<p>Whether the message is pinned.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessagementioneveryone-boolean","title":"EditedMessage.mentionEveryone : boolean","text":"<p>Whether the message mentions @everyone.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessagetts-boolean","title":"EditedMessage.tts : boolean","text":"<p>Whether the message was a TTS message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessagetimestamp-string","title":"EditedMessage.timestamp : string","text":"<p>A timestamp of when the message was sent in ISO8601 format.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessageflags-messageflags","title":"EditedMessage.flags : MessageFlags","text":"<p>A MessageFlags object representing the message's flags.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessagewebhookid-string","title":"EditedMessage.webhookId : string","text":"<p>The webhook that sent the message's id.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#editedmessageeditedtimestamp-string","title":"EditedMessage.editedTimestamp : string","text":"<p>A timestamp of when the message was edited in ISO8601 format.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedMessage/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/EditedMessage/#editedmessagenewdata-dictionary-editedmessage","title":"EditedMessage.new(data : dictionary) : EditedMessage","text":"<p>This method returns a new EditedMessage object.</p> Warning <p>This method is not meant to be called outside of Voyager's internal code.</p> <p>Parameters</p> <ul> <li>data: A message object.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/","title":"EditedThreadMessage","text":""},{"location":"API%20Reference/EditedThreadMessage/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessageid-string","title":"EditedThreadMessage.id : string","text":"<p>The message's id.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagemessagetype-number","title":"EditedThreadMessage.messageType : number","text":"<p>The type of message the message is.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagecontent-string","title":"EditedThreadMessage.content : string","text":"<p>The message's content.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagechannelid-string","title":"EditedThreadMessage.channelId : string","text":"<p>The id of the channel the message was sent in.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessageauthor-author","title":"EditedThreadMessage.author : Author","text":"<p>The the author of the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessageembeds-number-embed","title":"EditedThreadMessage.embeds : {[number] : Embed}","text":"<p>A table of embeds that are attached to the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagereactions-number-reaction","title":"EditedThreadMessage.reactions : {[number] : Reaction}","text":"<p>A table of reactions to the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagementions-number-user","title":"EditedThreadMessage.mentions : {[number] : User}","text":"<p>A table of users mentioned in the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagementionroles-number-string","title":"EditedThreadMessage.mentionRoles : {[number] : string}","text":"<p>A table of role ids mentioned in the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagepinned-boolean","title":"EditedThreadMessage.pinned : boolean","text":"<p>Whether the message is pinned.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagementioneveryone-boolean","title":"EditedThreadMessage.mentionEveryone : boolean","text":"<p>Whether the message mentions @everyone.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagetts-boolean","title":"EditedThreadMessage.tts : boolean","text":"<p>Whether the message was a TTS message.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagetimestamp-string","title":"EditedThreadMessage.timestamp : string","text":"<p>A timestamp of when the message was sent in ISO8601 format.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessageflags-messageflags","title":"EditedThreadMessage.flags : MessageFlags","text":"<p>A MessageFlags object representing the message's flags.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagewebhookid-string","title":"EditedThreadMessage.webhookId : string","text":"<p>The webhook that sent the message's id.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessageposition-number","title":"EditedThreadMessage.position: number","text":"<p>A number that represents the approximate position of the message in a thread.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessageeditedtimestamp-string","title":"EditedThreadMessage.editedTimestamp: string","text":"<p>When the message was edited in ISO8601 format.</p> <p></p> <p></p>"},{"location":"API%20Reference/EditedThreadMessage/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/EditedThreadMessage/#editedthreadmessagenewdata-dictionary-editedthreadmessage","title":"EditedThreadMessage.new(data : dictionary) : EditedThreadMessage","text":"<p>This method returns a new EditedThreadMessage object.</p> Warning <p>This method is not meant to be called outside of Voyager's internal code.</p> <p>Parameters</p> <ul> <li>data: A message object.</li> </ul>"},{"location":"API%20Reference/Embed/","title":"Embed","text":""},{"location":"API%20Reference/Embed/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/Embed/#embedtitle-string","title":"Embed.title : string?","text":"<p>The title attached to the embed.</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embeddescription-string","title":"Embed.description : string?","text":"<p>The description attached to the embed.</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedurl-string","title":"Embed.url : string?","text":"<p>The url attached to the embed's title.</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedtimestamp-string","title":"Embed.timestamp : string?","text":"<p>An ISO8601 timestamp attached to the embed's footer.</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedcolor-number","title":"Embed.color : number?","text":"<p>The embed's color code.</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedfooter-text-string-icon_url-string","title":"Embed.footer : {text : string, icon_url : string?}?","text":"<p>The embed's footer.</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedimage-url-string","title":"Embed.image : {url : string}?","text":"<p>The embed's image.</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedthumbnail-url-string","title":"Embed.thumbnail : {url : string}?","text":"<p>The embed's thumbnail.</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedauthor-name-string-url-string-icon_url-string","title":"Embed.author : {name : string, url : string?, icon_url : string?}?","text":"<p>The embed's author.</p> Warning <p>This is NOT an author object!</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedfields-number-name-string-value-string-inline-boolean","title":"Embed.fields : {[number] : {name : string, value : string, inLine : boolean?}}?","text":"<p>A table of field objects that are attached to the embed.</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/Embed/#embednewtitle-string-description-string-url-string-embed","title":"Embed.new(title : string?, description : string?, url : string?) : Embed","text":"<p>This method returns a new Embed object.</p> <p>Parameters</p> <ul> <li>title: The title of the embed.</li> <li>description: The description of the embed.</li> <li>url: The url attached to the embed's title.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedsettitletitle-string-nil","title":"Embed:setTitle(title : string) : nil","text":"<p>This method overrides the embed's title with a new one.</p> <p>Parameters</p> <ul> <li>title: The title of the embed.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedsetdescriptiondescription-string-nil","title":"Embed:setDescription(description : string) : nil","text":"<p>This method overrides the embed's description with a new one.</p> <p>Parameters</p> <ul> <li>description: The description of the embed.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedseturlurl-string-nil","title":"Embed:setUrl(url : string) : nil","text":"<p>This method overrides the embed's url with a new one.</p> <p>Parameters</p> <ul> <li>url: The url attached to the embed's title.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedsettimestampcustomtimestamp-string-nil","title":"Embed:setTimestamp(customTimestamp : string?) : nil","text":"<p>This method overrides the embed's timestamp with a new one.</p> Note <p>If customTimestamp is left nil then the current timestamp will be used instead.</p> <p>Parameters</p> <ul> <li>customTimestamp: A custom ISO8601 timestamp for the embed.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedsetcolorcolor3-color3-nil","title":"Embed:setColor(color3 : Color3) : nil","text":"<p>This method overrides the embed's color code with a new one.</p> <p>Parameters</p> <ul> <li>color3: A color3 value.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedsetfootertext-string-iconurl-string-nil","title":"Embed:setFooter(text : string, iconUrl : string?) : nil","text":"<p>This method overrides the embed's footer with a new one.</p> Warning <p>Only HTTPs urls are supported for the iconUrl parameter.</p> <p>Parameters</p> <ul> <li>text: The footer's text.</li> <li>iconUrl: The footer's url.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedsetimageurl-string-nil","title":"Embed:setImage(url : string) : nil","text":"<p>This method overrides the embed's image with a new one.</p> Warning <p>Only HTTPs urls are supported for the url parameter.</p> <p>Parameters</p> <ul> <li>url: The image's url.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedsetthumbnailurl-string-nil","title":"Embed:setThumbnail(url : string) : nil","text":"<p>This method overrides the embed's thumbnail with a new one.</p> Warning <p>Only HTTPs urls are supported for the url parameter.</p> <p>Parameters</p> <ul> <li>url: The thumbnail's url.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedsetauthorname-string-url-string-iconurl-string-nil","title":"Embed:setAuthor(name : string, url : string?, iconUrl : string?) : nil","text":"<p>This method overrides the embed's author with a new one.</p> Warning <p>Only HTTPs urls are supported for the iconUrl parameter.</p> <p>Parameters</p> <ul> <li>name: The author's name.</li> <li>url: The author's url.</li> <li>iconUrl: The icon's url.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedaddfieldname-string-value-string-inline-boolean-nil","title":"Embed:addField(name: string, value: string, inLine: boolean?): nil","text":"<p>This method adds a new field to the embed.</p> <p>Parameters</p> <ul> <li>name: The field's name.</li> <li>value: The field's value.</li> <li>inLine: Whether the field should display inline.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedtotalcharacters-number","title":"Embed:totalCharacters(): number","text":"<p>This method returns the total amount of characters in the embed.</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embedcolortorgb-r-number-g-number-b-number","title":"Embed:colorToRGB(): {r: number, g: number, b: number}?","text":"<p>This method returns the embed's color in rgb format.</p> <p></p> <p></p>"},{"location":"API%20Reference/Embed/#embed_validate-boolean-string","title":"Embed:_validate() : (boolean, string?)","text":"<p>This method validates the embed to avoid making a pointless request to discord.</p> Warning <p>This method is not meant to be used outside Voyager's internal code.</p> <p></p> <p></p>"},{"location":"API%20Reference/Emoji/","title":"Emoji","text":""},{"location":"API%20Reference/Emoji/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/Emoji/#emojiid-string","title":"Emoji.id : string?","text":"<p>The emoji's id.</p> Note <p>If the emoji isn't custom this will always be nil.</p> <p></p> <p></p>"},{"location":"API%20Reference/Emoji/#emojiname-string","title":"Emoji.name : string","text":"<p>The emoji's name or unicode character.</p> Note <p>If the emoji is a custom emoji then this'll return the name of the emoji. Otherwise it'll return it's unicode character.</p> <p></p> <p></p>"},{"location":"API%20Reference/Emoji/#emojianimated-boolean","title":"Emoji.animated : boolean","text":"<p>Whether the emoji is animated.</p> <p></p> <p></p>"},{"location":"API%20Reference/Emoji/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/Emoji/#emojinewdata-dictionary-emoji","title":"Emoji.new(data : dictionary) : Emoji","text":"<p>This function returns a new Emoji object.</p> Warning <p>This method is not meant to be called outside of Voyager's internal code.</p> <p>Parameters</p> <ul> <li>data: An Emoji object.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Enum/","title":"Enum","text":""},{"location":"API%20Reference/Enum/#enums","title":"<p>Enums</p>","text":""},{"location":"API%20Reference/Enum/#enumuserpublicflags-dictionary","title":"Enum.UserPublicFlags : dictionary","text":"<p>A dictionary of user flags. Offical docs reference</p> <p></p> <p></p>"},{"location":"API%20Reference/Enum/#enummessageflags-dictionary","title":"Enum.MessageFlags : dictionary","text":"<p>A dictionary of message flags. Offical docs reference</p> <p></p> <p></p>"},{"location":"API%20Reference/Enum/#enumavatarimageformats-dictionary","title":"Enum.AvatarImageFormats : dictionary","text":"<p>A dictionary of strings that represent image formats. Offical docs reference</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/","title":"Message","text":""},{"location":"API%20Reference/Message/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/Message/#messageid-string","title":"Message.id : string","text":"<p>The message's id.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messagemessagetype-number","title":"Message.messageType : number","text":"<p>The type of message the message is.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messagecontent-string","title":"Message.content : string","text":"<p>The message's content.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messagechannelid-string","title":"Message.channelId : string","text":"<p>The id of the channel the message was sent in.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messageauthor-author","title":"Message.author : Author","text":"<p>The the author of the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messageembeds-number-embed","title":"Message.embeds : {[number] : Embed}","text":"<p>A table of embeds that are attached to the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messagereactions-number-reaction","title":"Message.reactions : {[number] : Reaction}","text":"<p>A table of reactions to the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messagementions-number-user","title":"Message.mentions : {[number] : User}","text":"<p>A table of users mentioned in the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messagementionroles-number-string","title":"Message.mentionRoles : {[number] : string}","text":"<p>A table of role ids mentioned in the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messagepinned-boolean","title":"Message.pinned : boolean","text":"<p>Whether the message is pinned.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messagementioneveryone-boolean","title":"Message.mentionEveryone : boolean","text":"<p>Whether the message mentions @everyone.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messagetts-boolean","title":"Message.tts : boolean","text":"<p>Whether the message was a TTS message.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messagetimestamp-string","title":"Message.timestamp : string","text":"<p>A timestamp of when the message was sent in ISO8601 format.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messageflags-messageflags","title":"Message.flags : MessageFlags","text":"<p>A MessageFlags object representing the message's flags.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#messagewebhookid-string","title":"Message.webhookId : string","text":"<p>The webhook that sent the message's id.</p> <p></p> <p></p>"},{"location":"API%20Reference/Message/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/Message/#messagenewdata-dictionary-message","title":"Message.new(data: dictionary): Message","text":"<p>This method returns a new Message object.</p> Warning <p>This method is not meant to be used outside Voyager's internal code.</p> <p>Parameters</p> <ul> <li>data: A message object.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/MessageFlags/","title":"MessageFlags","text":""},{"location":"API%20Reference/MessageFlags/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/MessageFlags/#messageflagsvalue-number","title":"MessageFlags.value : number","text":"<p>Flags combined as a bitfield.</p> <p></p> <p></p>"},{"location":"API%20Reference/MessageFlags/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/MessageFlags/#messageflagsfrombitfieldvalue-number-messageflags","title":"MessageFlags.fromBitfield(value : number) : MessageFlags","text":"<p>This method returns a new MessageFlags object.</p> <p>Parameters:</p> <ul> <li>value: Default bitfield.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/MessageFlags/#messageflagsfromflagsflags-number-number-messageflags","title":"MessageFlags.fromFlags(flags : {[number] : number}) : MessageFlags","text":"<p>This method returns a new MessageFlags object from a table of flags.</p> Tip <p>You can use Enum.MessageFlags to fill out the flags parameter.</p> <p>Parameters</p> <ul> <li>flags: A table of message flags.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/MessageFlags/#messageflagshasflagflag-number-boolean","title":"MessageFlags:hasFlag(flag : number) : boolean","text":"<p>This method will check whether the bitfield contains a specific flag.</p> Tip <p>You can use Enum.MessageFlags to fill out the flag parameter.</p> <p>Parameters</p> <ul> <li>flag: The flag that'll be looked for.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/MessageFlags/#messageflagssetflagflag-number-toggle-boolean-nil","title":"MessageFlags:setFlag(flag : number, toggle : boolean): nil","text":"<p>This method will toggle a flag in the bitfield either to true or false.</p> Tip <p>You can use Enum.MessageFlags to fill out the flag parameter.</p> <p>Parameters</p> <ul> <li>flag: A flag.</li> <li>toggle: If true the flag will be added to bitfield, otherwise the flag will be removed from the bitfield.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/OptionalExecuteInfo/","title":"OptionalExecuteInfo","text":""},{"location":"API%20Reference/OptionalExecuteInfo/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/OptionalExecuteInfo/#optionalexecuteinfothreadid-string","title":"OptionalExecuteInfo.threadId : string?","text":"<p>The id of the thread the message should go to.</p> <p></p> <p></p>"},{"location":"API%20Reference/OptionalExecuteInfo/#optionalexecuteinfotts-boolean","title":"OptionalExecuteInfo.tts : boolean","text":"<p>Whether the message should be tts.</p> <p></p> <p></p>"},{"location":"API%20Reference/OptionalExecuteInfo/#optionalexecuteinfousernameoverride-string","title":"OptionalExecuteInfo.usernameOverride : string?","text":"<p>An override for the webhook's username.</p> <p></p> <p></p>"},{"location":"API%20Reference/OptionalExecuteInfo/#optionalexecuteinfoavataroverride-string","title":"OptionalExecuteInfo.avatarOverride : string?","text":"<p>An override for the webhook's avatar.</p> <p></p> <p></p>"},{"location":"API%20Reference/OptionalExecuteInfo/#optionalexecuteinfomessageflags-messageflags","title":"OptionalExecuteInfo.messageFlags : MessageFlags","text":"<p>A MessageFlags object.</p> <p></p> <p></p>"},{"location":"API%20Reference/OptionalExecuteInfo/#optionalexecuteinfothreadname-string","title":"OptionalExecuteInfo.threadName : string?","text":"<p>The name of the thread to create.</p> Warning <p>Requires the webhook's channel to be a forum channel!</p> <p></p> <p></p>"},{"location":"API%20Reference/OptionalExecuteInfo/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/OptionalExecuteInfo/#optionalexecuteinfonewthreadid-string-tts-boolean-usernameoverride-string-avataroverride-string-messageflags-messageflags-threadname-string-optionalexecuteinfo","title":"OptionalExecuteInfo.new(threadId : string?, tts : boolean?, usernameOverride : string?, avatarOverride : string?, messageFlags : MessageFlags?, threadName : string?) : OptionalExecuteInfo","text":"<p>This method returns a new OptionalExecuteInfo object.</p> Warning <p>If both threadId and threadName are given an error will occur!</p> Note <p>If tts is left nil it will default to false.</p> Note <p>If messageFlags is left nil it will default to a MessageFlags object with a value of 0.</p> <p>Parameters</p> <ul> <li>threadId: The id of the thread the message should be sent to.</li> <li>tts: Whether the message should be tts.</li> <li>usernameOverride: An override for the webhook's username.</li> <li>avatarOverride: An override for the webhook's avatar.</li> <li>messageFlags: A MessageFlags object.</li> <li>threadName: Name of the thread to create.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/PublicUserFlags/","title":"PublicUserFlags","text":""},{"location":"API%20Reference/PublicUserFlags/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/PublicUserFlags/#publicuserflagsvalue-number","title":"PublicUserFlags.value : number","text":"<p>Flags combined as a bitfield.</p> <p></p> <p></p>"},{"location":"API%20Reference/PublicUserFlags/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/PublicUserFlags/#publicuserflagsfrombitfieldvalue-number-publicuserflags","title":"PublicUserFlags.fromBitfield(value : number) : PublicUserFlags","text":"<p>This method returns a new PublicUserFlags object.</p> Warning <p>This method is not meant to be called outside of Voyager's internal code.</p> <p>Parameters</p> <ul> <li>value: A bitfield.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/PublicUserFlags/#publicuserflagshasflagflag-number-boolean","title":"PublicUserFlags:hasFlag(flag : number) : boolean","text":"<p>This method will check whether the bitfield contains a specific flag.</p> Tip <p>You can use Enum.UserPublicFlags to fill out the flag parameter.</p> <p>Parameters</p> <ul> <li>flag: The flag that'll be looked for.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/PublicUserFlags/#publicuserflagssetflagflag-number-toggle-boolean-nil","title":"PublicUserFlags:setFlag(flag : number, toggle : boolean) : nil","text":"<p>This method will toggle a flag in the bitfield either to true or false.</p> Tip <p>You can use Enum.UserPublicFlags to fill out the flag parameter.</p> <p>Parameters</p> <ul> <li>flag: A flag.</li> <li>toggle: If true the flag will be added to bitfield, otherwise the flag will be removed from the bitfield.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/PublicUserFlags/#publicuserflagsgetflags-number-number","title":"PublicUserFlags:getFlags() : {[number] : number}","text":"<p>This method will return a table of flags that are in the bitfield.</p> <p></p> <p></p>"},{"location":"API%20Reference/Reaction/","title":"Reaction","text":""},{"location":"API%20Reference/Reaction/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/Reaction/#reactionemoji-emoji","title":"Reaction.emoji : Emoji","text":"<p>The emoji that was used to react to the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/Reaction/#reactionme-boolean","title":"Reaction.me : boolean","text":"<p>Whether the webhook reacted to the message using this emoji.</p> <p></p> <p></p>"},{"location":"API%20Reference/Reaction/#reactioncount-number","title":"Reaction.count : number","text":"<p>The number of times this emoji has been used to react to the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/Reaction/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/Reaction/#reactionnewdata-dictionary-reaction","title":"Reaction.new(data : dictionary) : Reaction","text":"<p>This method returns a new Reaction object.</p> Warning <p>This method is not meant to be called outside of Voyager's internal code.*</p> <p>Parameters</p> <ul> <li>data: A reaction object.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/","title":"ThreadMessage","text":""},{"location":"API%20Reference/ThreadMessage/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/ThreadMessage/#threadmessageid-string","title":"ThreadMessage.id : string","text":"<p>The message's id.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessagemessagetype-number","title":"ThreadMessage.messageType : number","text":"<p>The type of message the message is.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessagecontent-string","title":"ThreadMessage.content : string","text":"<p>The message's content.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessagechannelid-string","title":"ThreadMessage.channelId : string","text":"<p>The id of the channel the message was sent in.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessageauthor-author","title":"ThreadMessage.author : Author","text":"<p>The the author of the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessageembeds-number-embed","title":"ThreadMessage.embeds : {[number] : Embed}","text":"<p>A table of embeds that are attached to the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessagereactions-number-reaction","title":"ThreadMessage.reactions : {[number] : Reaction}","text":"<p>A table of reactions to the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessagementions-number-user","title":"ThreadMessage.mentions : {[number] : User}","text":"<p>A table of users mentioned in the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessagementionroles-number-string","title":"ThreadMessage.mentionRoles : {[number] : string}","text":"<p>A table of role ids mentioned in the message.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessagepinned-boolean","title":"ThreadMessage.pinned : boolean","text":"<p>Whether the message is pinned.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessagementioneveryone-boolean","title":"ThreadMessage.mentionEveryone : boolean","text":"<p>Whether the message mentions @everyone.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessagetts-boolean","title":"ThreadMessage.tts : boolean","text":"<p>Whether the message was a TTS message.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessagetimestamp-string","title":"ThreadMessage.timestamp : string","text":"<p>A timestamp of when the message was sent in ISO8601 format.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessageflags-messageflags","title":"ThreadMessage.flags : MessageFlags","text":"<p>A MessageFlags object representing the message's flags.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessagewebhookid-string","title":"ThreadMessage.webhookId : string","text":"<p>The webhook that sent the message's id.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#threadmessageposition-number","title":"ThreadMessage.position: number","text":"<p>A number that represents the approximate position of the message in a thread.</p> <p></p> <p></p>"},{"location":"API%20Reference/ThreadMessage/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/ThreadMessage/#threadmessagenewdata-dictionary-threadmessage","title":"ThreadMessage.new(data : dictionary) : ThreadMessage","text":"<p>This method returns a new ThreadMessage object.</p> Warning <p>This method is not meant to be called outside of Voyager's internal code.</p> <p>Parameters</p> <ul> <li>data: A message object.</li> </ul>"},{"location":"API%20Reference/User/","title":"User","text":""},{"location":"API%20Reference/User/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/User/#userid-string","title":"User.id : string","text":"<p>The user's discord id.</p> <p></p> <p></p>"},{"location":"API%20Reference/User/#userusername-string","title":"User.username : string","text":"<p>The user's discord username.</p> <p></p> <p></p>"},{"location":"API%20Reference/User/#useravatar-string","title":"User.avatar : string","text":"<p>The user's discord avatar hash.</p> <p></p> <p></p>"},{"location":"API%20Reference/User/#userdiscriminator-string","title":"User.discriminator : string","text":"<p>The user's discord discriminator.</p> Deprecation Notice <p>This property has been deprecated. Please edit any code that uses it as it will be removed soon.</p> <p></p> <p></p>"},{"location":"API%20Reference/User/#userbot-boolean","title":"User.bot : boolean","text":"<p>Whether the user is a bot.</p> <p></p> <p></p>"},{"location":"API%20Reference/User/#userglobalname-string","title":"User.globalName : string?","text":"<p>the user's display name on Discord.</p> <p></p> <p></p>"},{"location":"API%20Reference/User/#userpublicflags-publicuserflags","title":"User.publicFlags : PublicUserFlags","text":"<p>The user's flags.</p> <p></p> <p></p>"},{"location":"API%20Reference/User/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/User/#usernewdata-dictionary-user","title":"User.new(data : dictionary) : User","text":"<p>This method returns a new User object.</p> Warning <p>This method is not meant to be called outside of Voyager's internal code.</p> <p>Parameters</p> <ul> <li>data: A user object.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/User/#usergetavatarurlsize-number-imageformat-string-string","title":"User:getAvatarUrl(size : number?, imageFormat : string?) : string?","text":"<p>This method will return the user's avatar url.</p> Warning <p>The size parameter can only be a power of two between 16 and 4096.</p> Info <p>If the imageFormat paramiter is left out. It will defualt to .png.</p> Tip <p>Use Enum.AvatarImageFormats to fill in the imageFormat parameter.</p> <p>Parameters</p> <ul> <li>size: The desired size the avatar should be.</li> <li>imageFormat: The format the author's avatar should be returned as.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/User/#userhasanimatedavatar-boolean","title":"User:hasAnimatedAvatar(): boolean","text":"<p>This method checks whether the user has an animated avatar.</p> <p></p> <p></p>"},{"location":"API%20Reference/Webhook/","title":"Webhook","text":""},{"location":"API%20Reference/Webhook/#types","title":"<p>Types</p>","text":""},{"location":"API%20Reference/Webhook/#ratelimitinfo","title":"RatelimitInfo","text":""},{"location":"API%20Reference/Webhook/#ratelimitinfoxratelimitlimit-number","title":"RatelimitInfo.XRatelimitLimit : number?","text":""},{"location":"API%20Reference/Webhook/#ratelimitinfoxratelimitremaining-number","title":"RatelimitInfo.XRatelimitRemaining : number?","text":""},{"location":"API%20Reference/Webhook/#ratelimitinfoxratelimitreset-string","title":"RatelimitInfo.XRatelimitReset : string?","text":""},{"location":"API%20Reference/Webhook/#ratelimitinfoxratelimitresetafter-number","title":"RatelimitInfo.XRatelimitResetAfter : number?","text":""},{"location":"API%20Reference/Webhook/#ratelimitinfoxratelimitbucket-string","title":"RatelimitInfo.XRatelimitBucket : string?","text":""},{"location":"API%20Reference/Webhook/#requeststatus","title":"RequestStatus","text":""},{"location":"API%20Reference/Webhook/#requeststatussuccess-boolean","title":"RequestStatus.success : boolean","text":""},{"location":"API%20Reference/Webhook/#requeststatusstatuscode-number","title":"RequestStatus.statusCode : number","text":""},{"location":"API%20Reference/Webhook/#requeststatusstatusmessage-string","title":"RequestStatus.statusMessage : string","text":""},{"location":"API%20Reference/Webhook/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/Webhook/#webhookid-string","title":"Webhook.id : string","text":"<p>The webhook's id.</p> <p></p> <p></p>"},{"location":"API%20Reference/Webhook/#webhooktoken-string","title":"Webhook.token : string","text":"<p>The webhook's token.</p> Danger <p>Never share this with anyone! As leaking this value to someone gives them full access to your webhook.</p> <p></p> <p></p>"},{"location":"API%20Reference/Webhook/#webhookbaseurl-string","title":"Webhook.baseUrl : string","text":"<p>The webhook's base url.</p> <p></p> <p></p>"},{"location":"API%20Reference/Webhook/#webhookratelimitinfo-ratelimitinfo","title":"Webhook.ratelimitInfo : RatelimitInfo","text":"<p>The latest ratelimit information given to the webhook by Discord. Offical docs reference</p> Note <p>All of the values inside ratelimitInfo will be nil until you make a request to Discord via :execute, :editMessage or :deleteMessage.</p> Tip <p>These values can be used to avoid getting ratelimited from the proxy.</p> <p></p> <p></p>"},{"location":"API%20Reference/Webhook/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/Webhook/#webhooknewid-string-token-string-customproxyurl-string-webhook","title":"Webhook.new(id : string, token : string, customProxyUrl : string?) : Webhook","text":"<p>This method returns a new Webhook object.</p> <p>Parameters</p> <ul> <li>id: The webhook's id.</li> <li>token: The webhook's token.</li> <li>customProxyUrl: The base url of a self hosted WebhookProxy. </li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Webhook/#webhookexecutecontent-string-embeds-number-embed-queue-boolean-waitformessage-boolean-optionalexecuteinfo-optionalexecuteinfo-message-threadmessage-requeststatus","title":"Webhook:execute(content : string?, embeds : {[number] : Embed}?, queue : boolean, waitForMessage : boolean, optionalExecuteInfo : OptionalExecuteInfo?) : (Message? | ThreadMessage?, RequestStatus)","text":"<p>This method sends a message to Discord.</p> Note <p>If both queue and waitForMessage are true nil will be returned.</p> Tip <p>If you dont feel like making your own ratelimit handler set queue to true. This will ensure the message is sent to Discord. The only down side is it may take a few more seconds to show up depending on how busy the queue is.</p> <p>Parameters</p> <ul> <li>content: The message's content.</li> <li>embeds: A table of embeds that'll be attached to the message.</li> <li>queue: Whether to queue the request, this will make sure the message is sent.</li> <li>waitForMessage: Whether to wait for the message to be returned. If this is set to true a Message or ThreadMessage object will be returned depending on where the message was sent.</li> <li>optionalExecuteInfo: Optional extra information for the request.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Webhook/#webhookeditmessagemessageid-string-content-string-embeds-number-embed-threadid-string-editedmessage-editedthreadmessage-requeststatus","title":"Webhook:editMessage(messageId : string, content : string??, embeds : {[number] : Embed}?, threadId : string?) : (EditedMessage | EditedThreadMessage, RequestStatus)","text":"<p>This method edits a message sent by the webhook.</p> <p>Parameters</p> <ul> <li>messageId: The message you wanna edit's id.</li> <li>content: The new content that'll override the old content.</li> <li>embeds: The new embeds that'll override the old embeds.</li> <li>threadId: The id of the thread the message is in.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Webhook/#webhookdeletemessagemessageid-string-threadid-string-requeststatus","title":"Webhook:deleteMessage(messageId : string, threadId : string?) : RequestStatus","text":"<p>This method deletes a message sent by the webhook.</p> <p>Parameters</p> <ul> <li>messageId: The message you wanna delete's id.</li> <li>threadId: The id of the thread the message is in.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Webhook/#webhook_validateexecuterequestcontent-string-embeds-number-embed-optionalexecuteinfo-optionalexecuteinfo-boolean-string","title":"Webhook:_validateExecuteRequest(content : string?, embeds : {[number] : Embed}?, optionalExecuteInfo : OptionalExecuteInfo?) : (boolean, string?)","text":"<p>This method validates data given to :execute before sending it to Discord. This is done to avoid making pointless requests to the proxy and Discord.</p> Warning <p>This method is not meant to be used outside Voyager's internal code.</p> <p>Parameters</p> <ul> <li>content: The content of the message.</li> <li>embeds: A table of Embed objects.</li> <li>optionalExecuteInfo: A OptionalExecuteInfo object.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Webhook/#webhook_validateeditmessagerequestcontent-string-embeds-number-embed-boolean-string","title":"Webhook:_validateEditMessageRequest(content : string?, embeds : {[number] : Embed}?) : (boolean, string?)","text":"<p>This method validates data given to :editMessage before sending it to Discord. This is done to avoid making pointless requests to the proxy and Discord.</p> Warning <p>This method is not meant to be used outside Voyager's internal code.</p> <p>Parameters</p> <ul> <li>content: The content of the execute request.</li> <li>embeds: The embeds of the execute request.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/Webhook/#webhook_requesturl-string-method-string-body-contenttype-string-requeststatus","title":"Webhook:_request(url : string, method : string, body : {}?, contentType : string) : ({}?, RequestStatus)","text":"<p>This method is used to make HTTP requests to the proxy.</p> Warning <p>This method is not meant to be used outside Voyager's internal code.</p> <p>Parameters</p> <ul> <li>url: The url the request will be sent to.</li> <li>method: The HTTP method needed to make the request.</li> <li>body: The body of the request.</li> <li>contentType: The content type to use in the request header.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/bases/BaseFlags/","title":"BaseFlags","text":""},{"location":"API%20Reference/bases/BaseFlags/#properties","title":"<p>Properties</p>","text":""},{"location":"API%20Reference/bases/BaseFlags/#baseflagsvalue-number","title":"BaseFlags.value : number","text":"<p>Flags combined as a bitfield.</p> <p></p> <p></p>"},{"location":"API%20Reference/bases/BaseFlags/#methods","title":"<p>Methods</p>","text":""},{"location":"API%20Reference/bases/BaseFlags/#baseflagsfrombitfieldvalue-number-baseflags","title":"BaseFlags.fromBitfield(value : number) : BaseFlags","text":"<p>This method returns a new BaseFlags object.</p> Warning <p>This method is not meant to be called outside of Voyager's internal code.</p> <p>Parameters</p> <ul> <li>value: Default bitfield.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/bases/BaseFlags/#baseflagshasflagflag-number-boolean","title":"BaseFlags:hasFlag(flag : number) : boolean","text":"<p>This method will check whether the bitfield contains the passed flag.</p> <p>Parameters</p> <ul> <li>flag: The flag that'll be looked for.</li> </ul> <p></p> <p></p>"},{"location":"API%20Reference/bases/BaseFlags/#baseflagssetflagflag-number-toggle-boolean-nil","title":"BaseFlags:setFlag(flag : number, toggle : boolean) : nil","text":"<p>This method will toggle a flag in the bitfield either to true or false.</p> <p>Parameters</p> <ul> <li>flag: A flag.</li> <li>toggle: If true the flag will be added to bitfield, otherwise the flag will be removed from the bitfield.</li> </ul> <p></p> <p></p>"},{"location":"Tutorial/","title":"Index","text":"<p>In this tutorial you will learn how to use Voyager. You are required to know the basics of luau. It is recommended that you know some basic OOP concepts as well but it's not needed. It is also recommended that you read through the entire page instead of skimming through it, this is to ensure you don't miss anything important.</p> <p>If at any point you start struggling trying to understand something, message me on the devforum! </p> Warning <p>Please only do this as the last resort, and if you do send me a message, include as much information as you can. And lastly do not ask me to code you a solution, as I will promptly ghost you.</p>"},{"location":"Tutorial/error-handling/","title":"Error Handling","text":""},{"location":"Tutorial/error-handling/#why-should-i-handle-these-errors","title":"Why should I handle these errors?","text":"<p>Not having any logic in place to handle errors is very bad practice, as data integrity may be compromised leading to your script possibly breaking. Error handling will ensure your script works as intended, so it is vital to add some basic error handling logic to your script when using Voyager.</p>"},{"location":"Tutorial/error-handling/#basic-error-handling","title":"Basic error handling","text":"<pre><code>local Voyager = path_here.Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nwebhook:execute(\"Hello, World!\", nil, true, false)\n</code></pre> <p>All of the webhook's functions excluding some private ones return a RequestStatus object. With this object you can easily handle any error that may occur.</p> <p>First we have to put the RequestStatus object into a variable</p> <pre><code>local Voyager = path_here.Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal _, requestStatus = webhook:execute(\"Hello, World!\", nil, true, false)\n</code></pre> <p>The reason we put a _ before requestStatus is because execute can return a Message or ThreadMessage object but since waitForMessage is false it wont. And since it wont it'll return nil so we name it _ to show it'll not be used.</p> <p>Now we can check if the request was successfuly sent to the proxy.</p> <pre><code>local Voyager = path_here.Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal _, requestStatus = webhook:execute(\"Hello, World!\", nil, true, false)\nif requestStatus.success then\nprint(\"The message was sent!\")\nelse\nwarn(\"The message wasn't sent.\")\nend\n</code></pre> <p>And just like that we've set up basic error handling! The same thing can be done with :editMessage and :deleteMessage as well.</p>"},{"location":"Tutorial/error-handling/#advanced-error-handling","title":"Advanced error handling","text":"<p>Lets say we want to send a message to Discord and print that message's id. The code would look something like this.</p> <pre><code>local Voyager = path_here.Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal message = webhook:execute(\"Hello, World!\", nil, false, true)\nprint(message.id)\n</code></pre> <p>But doing this very unsafe as the request isn't guaranteed to be sent successfuly 100% of the time. And since the request isn't guaranteed to be sent the message variable may be nil, causing the script to error.</p> <p>Now we can set up some logic to prevent that from happening. First we should put the requestStatus object into a variable.</p> <pre><code>local Voyager = path_here.Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal message, requestStatus = webhook:execute(\"Hello, World!\", nil, false, true)\nprint(message.id)\n</code></pre> <p>Now that we have the requestStatus object we can set up the basic logic</p> <pre><code>local Voyager = path_here.Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal message, requestStatus = webhook:execute(\"Hello, World!\", nil, false, true)\nif requestStatus.success then\nprint(message.id)\nelse\nwarn(\"The message wasn't successfuly sent.\")\nend\n</code></pre> <p>Now we can take things a step further by handling specific HTTP errors like 429, 400, 500, 503, etc differently.</p> <pre><code>local Voyager = path_here.Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal message, requestStatus = webhook:execute(\"Hello, World!\", nil, false, true)\nif requestStatus.success then\nprint(message.id)\nelse\nif requestStatus.statusCode == 400 then\nwarn(\"Bad request!\")\nelseif requestStatus.statusCode == 429 then\nwarn(\"We've been ratelimited!\")\nelseif requestStatus.statusCode == 500 then\nwarn(\"Internal server error!\")\nelseif requestStatus.statusCode == 503 then\nwarn(\"The proxy is down!\")\nelse\nwarn(\"Request was not successful! \" .. requestStatus.statusCode .. \" \" .. requestStatus.statusMessage)\nend\nend\n</code></pre> <p>And just like that the script is now ready to handle any error it may come across.</p>"},{"location":"Tutorial/getting-started/","title":"Getting Started","text":"<p>Assuming you've followed the Installation guide in the overview, and have a webhook ready to go, if not follow this short tutorial by Discord. Keep your webhook url handy.</p>"},{"location":"Tutorial/getting-started/#sending-a-basic-message","title":"Sending a basic message","text":"<p>At the start of any script that uses Voyager, It all starts with first storing the path to the Voager folder in a variable.</p> <pre><code>local Voyager = path_here.Voyager\n</code></pre> <p>Then after that we can require all the objects we need. In this case, since we only need to send a basic message to Discord we only need the webhook object.</p> <pre><code>local Voyager = path_here.Voyager\nlocal webhook = require(Voyager.Webhook)\n</code></pre> <p>Now we need to make a new Webhook object to start sending messages, to do that call the Webhook object's constructor function to make a new Webhook object.</p> <pre><code>local Voyager = path_here.Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\n</code></pre> <p>The constructor function (webhook.new()) requires 2 arguments to be passed. </p> <p>The first one being the webhook's Id. </p> <p>The second one being the webhook's Token. </p> <p>To obtain these values look at the webhook's url. Example: https://discord.com/api/webhooks/id/token</p> <p>Now that we have a webhook object, we can send messages to Discord by using the webhook's execute function.</p> <pre><code>local Voyager = path_here.Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nwebhook:execute(\"Hello, World!\", nil, true, false)\n</code></pre> <p>As you can see the execute function takes at least 3 arguments. </p> <p>The first one being the optional content of the message.</p> <p>The second one being an optional table of Embed objects.</p> <p>The third one being whether we want to queue the request. </p> <p>The forth one being whether we want to wait for a message object to be returned. </p> <p>If you require a more indepth description about the Webhook object's execute function you can find it here under the methods section.</p> <p>The other objects mentioned in this tutorial will be given an proper explination later in the tutorial.</p> <p></p> <p>And it's as simple as that! if you run the script, a message like the one below should appear in the webhook's channel.</p> <p></p> <p></p>"},{"location":"Tutorial/getting-started/#making-something-with-voyager","title":"Making something with Voyager","text":"<p>Lets make a script that sends a Discord message when a player joins your game.</p> <p>Using the code from the previous tutorial we already have a good amount of work done.</p> <pre><code>local Voyager = path_here.Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nwebhook:execute(\"Hello, World!\", nil, true, false)\n</code></pre> <p>We will need to get the players service and use it's PlayerAdded event to execute an anonymous function.</p> <pre><code>local playerService = game:GetService(\"Players\")\nlocal Voyager = game:GetService(\"ServerStorage\").Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nplayerService.PlayerAdded:Connect(function(player : Player)\nend)\n</code></pre> <p>Now we'll make a new Embed object</p> <pre><code>local playerService = game:GetService(\"Players\")\nlocal Voyager = game:GetService(\"ServerStorage\").Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nplayerService.PlayerAdded:Connect(function(player : Player)\nlocal embed = require(Voyager.Embed).new()\nend)\n</code></pre> <p>Now we'll set the embed's author</p> <pre><code>local playerService = game:GetService(\"Players\")\nlocal Voyager = game:GetService(\"ServerStorage\").Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nplayerService.PlayerAdded:Connect(function(player : Player)\nlocal embed = require(Voyager.Embed).new()\nembed:setAuthor(player.DisplayName .. \" Joined!\", \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nend)\n</code></pre> <p>Now we'll give the embed some color</p> <pre><code>local playerService = game:GetService(\"Players\")\nlocal Voyager = game:GetService(\"ServerStorage\").Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nplayerService.PlayerAdded:Connect(function(player : Player)\nlocal embed = require(Voyager.Embed).new()\nembed:setAuthor(player.DisplayName .. \" Joined!\", \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(85, 255, 127))\nend)\n</code></pre> <p>Now we'll give the embed some fields so we can see some more information about the player</p> <pre><code>local playerService = game:GetService(\"Players\")\nlocal Voyager = game:GetService(\"ServerStorage\").Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nplayerService.PlayerAdded:Connect(function(player : Player)\nlocal embed = require(Voyager.Embed).new()\nembed:setAuthor(player.DisplayName .. \" Joined!\", \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(85, 255, 127))\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\", true)\nend)\n</code></pre> <p>Lastly for the embed customization, we're gonna add a timestamp to the embed's footer </p> <pre><code>local playerService = game:GetService(\"Players\")\nlocal Voyager = game:GetService(\"ServerStorage\").Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nplayerService.PlayerAdded:Connect(function(player : Player)\nlocal embed = require(Voyager.Embed).new()\nembed:setAuthor(player.DisplayName .. \" Joined!\", \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(85, 255, 127))\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\", true)\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:setTimestamp()\nend)\n</code></pre> <p>And now we can use the webhook's execute function to send the message</p> <pre><code>local playerService = game:GetService(\"Players\")\nlocal Voyager = game:GetService(\"ServerStorage\").Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nplayerService.PlayerAdded:Connect(function(player : Player)\nlocal embed = require(Voyager.Embed).new()\nembed:setAuthor(player.DisplayName .. \" Joined!\", \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(85, 255, 127))\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\", true)\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:setTimestamp()\nwebhook:execute(nil, {embed}, true, false)\nend)\n</code></pre> <p>Lastly we'll add some basic error handling</p> <pre><code>local playerService = game:GetService(\"Players\")\nlocal Voyager = game:GetService(\"ServerStorage\").Voyager\nlocal webhook = require(Voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nplayerService.PlayerAdded:Connect(function(player : Player)\nlocal embed = require(Voyager.Embed).new()\nembed:setAuthor(player.DisplayName .. \" Joined!\", \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(85, 255, 127))\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\", true)\nembed:setTimestamp()\nlocal _, requestStatus = webhook:execute(nil, {embed}, true, false)\nif not requestStatus.success then\nwarn(\"Request was not successful! \" .. requestStatus.statusCode .. \" \" .. requestStatus.statusMessage)\nend\nend)\n</code></pre>"},{"location":"Tutorial/getting-started/#real-use-case","title":"Real use case","text":"<p>Here is a real world use case. If you dont understand what a spesific function does, feel free to look it up in the docs for clarification. Embed docs</p> examples/gamepassPurchaseNotification.lua"},{"location":"Tutorial/securing-remotes/","title":"Securing Remotes","text":""},{"location":"Tutorial/securing-remotes/#why-should-i-secure-my-remotes","title":"Why should I secure my remotes?","text":"<p>Not securing your remotes leaves you in the mercy of exploiters. Exploiters can easily spam a remote event that sends a Discord message until you either get ratelimited or flatout banned from the proxy. So it is crucial secure your remotes to prevent this from happening.</p>"},{"location":"Tutorial/securing-remotes/#basic-remote-security","title":"Basic remote security","text":"<p>To show you how to secure a remote the feedback example found in examples will be used.</p> <p>The way we will prevent exploiters from spamming our remote is by putting players in cooldown when they fire the remote. So if a player fires the remote it'll put them on a cooldown and until the cooldown duration has passed they will not be able to send feedback.</p> examples\\playerFeedback.lua <p>First we will make 2 new variables, the first one will be a table that stores timestamps and the second one will store a number that'll represent the cooldown duration in seconds.</p> <pre><code>local voyager = game:GetService(\"ServerStorage\").Voyager\nlocal sendFeedbackRemote = game:GetService(\"ReplicatedStorage\").SendFeedback\nlocal webhook = require(voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal playersOnCooldown = {}\nlocal cooldownDuration = 60 * 10 -- 10 minutes\nsendFeedbackRemote.OnServerEvent:Connect(function(player : Player, feedback : string)\nlocal embed = require(voyager.Embed).new(nil, feedback)\nembed:setAuthor(\"Feedback from \" .. player.DisplayName, \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(0, 135, 255))\nembed:setTimestamp()\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\" , true)\nlocal _, requestStatus = webhook:execute(nil, {embed}, true, false)\nif not requestStatus.success then\nwarn(\"Request was not successful! \" .. requestStatus.statusCode .. \" \" .. requestStatus.statusMessage)\nend\nend)\n</code></pre> <p>Now we will need to make a function that'll check if a player can send feedback or not. The way it will decide if someone can send a message is by subtracting the current timestamp by their timestamp. Their timestamp reprisents when they last sent feedback.</p> <pre><code>local voyager = game:GetService(\"ServerStorage\").Voyager\nlocal sendFeedbackRemote = game:GetService(\"ReplicatedStorage\").SendFeedback\nlocal webhook = require(voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal playersOnCooldown = {}\nlocal cooldownDuration = 60 * 10 -- 10 minutes\nfunction canSendFeedback(player : Player) : boolean\nif not playersOnCooldown[player] then return true end\nif os.time() - playersOnCooldown[player] &gt; cooldownDuration then    \nreturn true\nelse\nreturn false\nend\nend\nsendFeedbackRemote.OnServerEvent:Connect(function(player : Player, feedback : string)\nlocal embed = require(voyager.Embed).new(nil, feedback)\nembed:setAuthor(\"Feedback from \" .. player.DisplayName, \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(0, 135, 255))\nembed:setTimestamp()\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\" , true)\nlocal _, requestStatus = webhook:execute(nil, {embed}, true, false)\nif not requestStatus.success then\nwarn(\"Request was not successful! \" .. requestStatus.statusCode .. \" \" .. requestStatus.statusMessage)\nend\nend)\n</code></pre> <p>Now all we need to do is check if the player can send feedback using the canSendFeedback function. If they can send feedback we will put them in cooldown and set their timestamp. Also we will add a PlayerRemoving function that removes the player's cooldown from the table if they leave, otherwise they will never be removed and will stay there until the server shuts down.</p> <pre><code>local voyager = game:GetService(\"ServerStorage\").Voyager\nlocal sendFeedbackRemote = game:GetService(\"ReplicatedStorage\").SendFeedback\nlocal webhook = require(voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal playersOnCooldown = {}\nlocal cooldownDuration = 60 * 10 -- 10 minutes\nfunction canSendFeedback(player : Player) : boolean\nif not playersOnCooldown[player] then return true end\nif os.time() - playersOnCooldown[player] &gt; cooldownDuration then    \nreturn true\nelse\nreturn false\nend\nend\ngame:GetService(\"Players\").PlayerRemoving:Connect(function(player : Player)\nplayersOnCooldown[player] = nil\nend)\nsendFeedbackRemote.OnServerEvent:Connect(function(player : Player, feedback : string)\nif not canSendFeedback(player) then return end\nplayersOnCooldown[player] = os.time()\nlocal embed = require(voyager.Embed).new(nil, feedback)\nembed:setAuthor(\"Feedback from \" .. player.DisplayName, \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(0, 135, 255))\nembed:setTimestamp()\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\" , true)\nlocal _, requestStatus = webhook:execute(nil, {embed}, true, false)\nif not requestStatus.success then\nwarn(\"Request was not successful! \" .. requestStatus.statusCode .. \" \" .. requestStatus.statusMessage)\nend\nend)\n</code></pre> <p>And just like that we've made the exploiter's life much harder with a few lines of code. Now they cannot spam feedback anymore. Now there is only one issue, they can still just rejoin the server, while this is extremely tedious some still may attempt this. If you'd like to patch this check out Advanced remote security.</p>"},{"location":"Tutorial/securing-remotes/#advanced-remote-security","title":"Advanced remote security","text":""},{"location":"Tutorial/securing-remotes/#join-lock-method","title":"Join Lock Method","text":"<p>One way we can solve the rejoining problem is by putting the player in cooldown when they join the game. no regular player would want to send feedback the instant they join the game so this will  most likely not affect regular players.</p> <p>We can do this by simply adding a PlayerAdded event and putting the player in cooldown when they join.</p> <pre><code>local voyager = game:GetService(\"ServerStorage\").Voyager\nlocal sendFeedbackRemote = game:GetService(\"ReplicatedStorage\").SendFeedback\nlocal webhook = require(voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal playersOnCooldown = {}\nlocal cooldownDuration = 60 * 10 -- 10 minutes\nfunction canSendFeedback(player : Player) : boolean\nif not playersOnCooldown[player] then return true end\nif os.time() - playersOnCooldown[player] &gt; cooldownDuration then    \nreturn true\nelse\nreturn false\nend\nend\ngame:GetService(\"Players\").PlayerAdded:Connect(function(player : Player)\nplayersOnCooldown[player] = os.time()\nend)\ngame:GetService(\"Players\").PlayerRemoving:Connect(function(player : Player)\nplayersOnCooldown[player] = nil\nend)\nsendFeedbackRemote.OnServerEvent:Connect(function(player : Player, feedback : string)\nif not canSendFeedback(player) then return end\nplayersOnCooldown[player] = os.time()\nlocal embed = require(voyager.Embed).new(nil, feedback)\nembed:setAuthor(\"Feedback from \" .. player.DisplayName, \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(0, 135, 255))\nembed:setTimestamp()\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\" , true)\nlocal _, requestStatus = webhook:execute(nil, {embed}, true, false)\nif not requestStatus.success then\nwarn(\"Request was not successful! \" .. requestStatus.statusCode .. \" \" .. requestStatus.statusMessage)\nend\nend)\n</code></pre>"},{"location":"Tutorial/securing-remotes/#datastore-method","title":"Datastore Method","text":"<p>Another way to solve this by storing the timestamp in a datastore, while this is more tedious to implement it allows us to set a higher cooldown duration. This is also useful if you have a big game, since every player will now have to wait a week to send more feedback. This will greatly decrease the amount of requests sent to the proxy.</p> <p>A regular datastore will be used, but this can also be done with ProfileService and Datastore2.</p> <p>First we will change cooldownDuration to last a week. Then we'll fetch the cooldownDatastore to use later. We will also fetch the players service since we will start using it more.</p> <pre><code>local voyager = game:GetService(\"ServerStorage\").Voyager\nlocal sendFeedbackRemote = game:GetService(\"ReplicatedStorage\").SendFeedback\nlocal webhook = require(voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal playersOnCooldown = {}\nlocal cooldownDuration = 60 * 60 * 24 * 7 -- 1 week\nlocal playerService = game:GetService(\"Players\")\nlocal cooldownDatastore = game:GetService(\"DataStoreService\"):GetDataStore(\"cooldownDatastore\")\nfunction canSendFeedback(player : Player) : boolean\nif not playersOnCooldown[player] then return true end\nif os.time() - playersOnCooldown[player] &gt; cooldownDuration then    \nreturn true\nelse\nreturn false\nend\nend\nplayerService.PlayerRemoving:Connect(function(player : Player)\nplayersOnCooldown[player] = nil\nend)\nsendFeedbackRemote.OnServerEvent:Connect(function(player : Player, feedback : string)\nif not canSendFeedback(player) then return end\nplayersOnCooldown[player] = os.time()\nlocal embed = require(voyager.Embed).new(nil, feedback)\nembed:setAuthor(\"Feedback from \" .. player.DisplayName, \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(0, 135, 255))\nembed:setTimestamp()\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\" , true)\nlocal _, requestStatus = webhook:execute(nil, {embed}, true, false)\nif not requestStatus.success then\nwarn(\"Request was not successful! \" .. requestStatus.statusCode .. \" \" .. requestStatus.statusMessage)\nend\nend)\n</code></pre> <p>Now we'll add a PlayerAdded event, and in that event we will fetch the player's timestamp and add it to the playersOnCooldown table.</p> <pre><code>local voyager = game:GetService(\"ServerStorage\").Voyager\nlocal sendFeedbackRemote = game:GetService(\"ReplicatedStorage\").SendFeedback\nlocal webhook = require(voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal playersOnCooldown = {}\nlocal cooldownDuration = 60 * 60 * 24 * 7 -- 1 week\nlocal playerService = game:GetService(\"Players\")\nlocal cooldownDatastore = game:GetService(\"DataStoreService\"):GetDataStore(\"cooldownDatastore\")\nfunction canSendFeedback(player : Player) : boolean\nif not playersOnCooldown[player] then return true end\nif os.time() - playersOnCooldown[player] &gt; cooldownDuration then    \nreturn true\nelse\nreturn false\nend\nend\nplayerService.PlayerAdded:Connect(function(player : Player)\nlocal success, result = pcall(function()\nplayersOnCooldown[player] = cooldownDatastore:GetAsync(player.UserId)\nend)\nif not success then warn(\"Unable to fetch player's data!\") end\nend)\nplayerService.PlayerRemoving:Connect(function(player : Player)\nplayersOnCooldown[player] = nil\nend)\nsendFeedbackRemote.OnServerEvent:Connect(function(player : Player, feedback : string)\nif not canSendFeedback(player) then return end\nplayersOnCooldown[player] = os.time()\nlocal embed = require(voyager.Embed).new(nil, feedback)\nembed:setAuthor(\"Feedback from \" .. player.DisplayName, \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(0, 135, 255))\nembed:setTimestamp()\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\" , true)\nlocal _, requestStatus = webhook:execute(nil, {embed}, true, false)\nif not requestStatus.success then\nwarn(\"Request was not successful! \" .. requestStatus.statusCode .. \" \" .. requestStatus.statusMessage)\nend\nend)\n</code></pre> <p>Now we'll edit the PlayerRemoving event to save the player's timestamp before removing it from the playersOnCooldown table.</p> <pre><code>local voyager = game:GetService(\"ServerStorage\").Voyager\nlocal sendFeedbackRemote = game:GetService(\"ReplicatedStorage\").SendFeedback\nlocal webhook = require(voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal playersOnCooldown = {}\nlocal cooldownDuration = 60 * 60 * 24 * 7 -- 1 week\nlocal playerService = game:GetService(\"Players\")\nlocal cooldownDatastore = game:GetService(\"DataStoreService\"):GetDataStore(\"cooldownDatastore\")\nfunction canSendFeedback(player : Player) : boolean\nif not playersOnCooldown[player] then return true end\nif os.time() - playersOnCooldown[player] &gt; cooldownDuration then    \nreturn true\nelse\nreturn false\nend\nend\nplayerService.PlayerAdded:Connect(function(player : Player)\nlocal success, result = pcall(function()\nplayersOnCooldown[player] = cooldownDatastore:GetAsync(player.UserId)\nend)\nif not success then warn(\"Unable to fetch player's data!\") end\nend)\nplayerService.PlayerRemoving:Connect(function(player : Player)\nlocal success, result = pcall(function()\ncooldownDatastore:SetAsync(player.UserId, playersOnCooldown[player])\nend)\nif not success then warn(\"Data was not saved!\") end\nplayersOnCooldown[player] = nil\nend)\nsendFeedbackRemote.OnServerEvent:Connect(function(player : Player, feedback : string)\nif not canSendFeedback(player) then return end\nplayersOnCooldown[player] = os.time()\nlocal embed = require(voyager.Embed).new(nil, feedback)\nembed:setAuthor(\"Feedback from \" .. player.DisplayName, \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(0, 135, 255))\nembed:setTimestamp()\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\" , true)\nlocal _, requestStatus = webhook:execute(nil, {embed}, true, false)\nif not requestStatus.success then\nwarn(\"Request was not successful! \" .. requestStatus.statusCode .. \" \" .. requestStatus.statusMessage)\nend\nend)\n</code></pre> <p>And lasty we will add a BindToClose event to make sure data isn't lost when the server shuts down.</p> <pre><code>local voyager = game:GetService(\"ServerStorage\").Voyager\nlocal sendFeedbackRemote = game:GetService(\"ReplicatedStorage\").SendFeedback\nlocal webhook = require(voyager.Webhook).new(\"webhookId\", \"webhookToken\")\nlocal playersOnCooldown = {}\nlocal cooldownDuration = 60 * 60 * 24 * 7 -- 1 week\nlocal playerService = game:GetService(\"Players\")\nlocal cooldownDatastore = game:GetService(\"DataStoreService\"):GetDataStore(\"cooldownDatastore\")\nfunction canSendFeedback(player : Player) : boolean\nif not playersOnCooldown[player] then return true end\nif os.time() - playersOnCooldown[player] &gt; cooldownDuration then    \nreturn true\nelse\nreturn false\nend\nend\nplayerService.PlayerAdded:Connect(function(player : Player)\nlocal success, result = pcall(function()\nplayersOnCooldown[player] = cooldownDatastore:GetAsync(player.UserId)\nend)\nif not success then warn(\"Unable to fetch player's data!\") end\nend)\nplayerService.PlayerRemoving:Connect(function(player : Player)\nlocal success, result = pcall(function()\ncooldownDatastore:SetAsync(player.UserId, playersOnCooldown[player])\nend)\nif not success then warn(\"Data was not saved!\") end\nplayersOnCooldown[player] = nil\nend)\ngame:BindToClose(function()\nfor _, player in playerService:GetPlayers() do\nlocal success, result = pcall(function()\ncooldownDatastore:SetAsync(player.UserId, playersOnCooldown[player])\nend)\nif not success then warn(\"Data was not saved!\") end\nend\nend)\nsendFeedbackRemote.OnServerEvent:Connect(function(player : Player, feedback : string)\nif not canSendFeedback(player) then return end\nplayersOnCooldown[player] = os.time()\nlocal embed = require(voyager.Embed).new(nil, feedback)\nembed:setAuthor(\"Feedback from \" .. player.DisplayName, \"https://www.roblox.com/users/\" .. player.UserId .. \"/profile\")\nembed:setColor(Color3.fromRGB(0, 135, 255))\nembed:setTimestamp()\nembed:addField(\"Account Age\", \"**\" .. player.AccountAge .. \"** Days\", true)\nembed:addField(\"Has Verified Badge?\", tostring(player.HasVerifiedBadge), true)\nembed:addField(\"From Game\", \"[Game Link](https://www.roblox.com/games/\" .. game.PlaceId .. \")\" , true)\nlocal _, requestStatus = webhook:execute(nil, {embed}, true, false)\nif not requestStatus.success then\nwarn(\"Request was not successful! \" .. requestStatus.statusCode .. \" \" .. requestStatus.statusMessage)\nend\nend)\n</code></pre>"}]}